
Made setup google doc
add other setup to it


Make it so script can be run anywhere as long as Actual with dot files is next to it!



ADD BATCH SCRIPT FOR GIT MINTTY CUSTOMIZATION
Copy .bashrc to C:\Users\%username%\
Rename to .bash_profile
Add to beginning (“COPY OF .BASHRC FOR GIT MINTTY”)
•	this will come at the begining of file >>log.txt
•	type log1.txt >> log.txt
•	del log1.txt
•	ren log.txt log1.txt




ADD LINUX PROGRAMMING FOR 4 MAIN LANGS:
- Add folder to repo: "Program_Templates"

- Add files: ctemp.c , cpptemp.cpp, javatemp.java, pytemp.py

- Add content to each 
	- Uses bashrc func for C99 one
	- For others, use most basic program from programming tutorials

- Add compiler aliases in bashrc for each

- Add template generator function
	- signature: gen_temp
	- If no arguments, print usage string
	- If c = copy ctemp.c  to pwd  etc (for all four)  
		- (maybe cat ~/LinuxFiles/ctemp.c > ctemp.c)
	- If doesnt match any = print usage string
	
- 
- In general setup script
	- C and C++ are installed
	- Add java install
	- Add python install




OTHER FEATURES
	
	
	
Add ability to give message if using old version of linux files
- write function
    - use -C to get to right direcotry
	- fetch first
	- git -C LinuxFiles  fetch --quiet
	- check status
	- git -C LinuxFiles status 
	- convert status into b
	if [[ `git status --porcelain` ]]; then
	  # Changes
	  # Only if it has changes = Give extra message "NOTICE: You are running on an old Linux Files configuration!"
	else
https://stackoverflow.com/questions/5143795/how-can-i-check-in-a-bash-script-if-my-local-git-repository-has-changes
- call it


BOTH BELOW briefly describes a command or C function
Add "describe" = and do both below!
"type" command 
"whatis" command



systeminfo function:
lsb_release -a
hostnamectl
cat /etc/*-release | uniq -u

ADD NEOFETCH SYS INFO



MORE LINUX QUIRKS

Add Ctrl-C is breake

output direction operators
| to pipe command input in another

“>“: Overwrites the existing file, or creates a file if the file of the mentioned name is not present in the directory.

“>>“: Appends the existing file, or creates a file if the file of the mentioned name is not present in the directory.



Ls takes both files and directories 

Wild cards

Start WildCard
The star wildcard (*) has the broadest meaning of any of the wildcards, as it can represent zero characters, all single characters or any string.

The question mark wildcard (?) is used as a wildcard character in shell commands to represent exactly one character, which can be any single character. Thus, two question marks in succession would represent any two characters in succession, and three question marks in succession would represent any string consisting of three characters.


Square Brackets Wildcard

The third type of wildcard in shell commands is a pair of square brackets, which can represent any of the characters enclosed in the brackets. Thus, for example, the following would provide information about all objects in the current directory that have an x, y and/or z in them:

file *[xyz]*

And the following would list all files that had an extension that begins with x, y or z:

ls *.[xyz]*

The same results can be achieved by merely using the star and question mark wildcards. However, it is clearly more efficient to use the bracket wildcard.

When a hyphen is used between two characters in the square brackets wildcard, it indicates a range inclusive of those two characters. For example, the following would provide information about all of the objects in the current directory that begin with any letter from a through f:

file [a-f]*

And the following would provide information about every object in the current directory whose name includes at least one numeral:

file *[0-9]*



Show path dirs line by line
sed 's/:/\n/g' <<< "$PATH"


Add top commands
, run this command to see a list of the top 10 commands you run most.

$ history | awk '{cmd[$2]++} END {for(elem in cmd) {print cmd[elem] " " elem}}' | sort -n -r | head -10
